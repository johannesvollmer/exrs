<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>exrs-wasm Demo</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
    }
    h1 {
      color: #fff;
      border-bottom: 2px solid #4a4a6a;
      padding-bottom: 10px;
    }
    h2 {
      color: #aaa;
      font-size: 1.1em;
      margin-top: 30px;
      margin-bottom: 15px;
    }
    .section {
      background: #252540;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      align-items: flex-end;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    label {
      font-size: 0.85em;
      color: #999;
    }
    input[type="number"], select {
      padding: 8px 12px;
      border: 1px solid #4a4a6a;
      border-radius: 4px;
      background: #1a1a2e;
      color: #fff;
      font-size: 14px;
      width: 100px;
    }
    select {
      width: 140px;
    }
    .radio-group {
      display: flex;
      gap: 15px;
    }
    .radio-group label {
      display: flex;
      align-items: center;
      gap: 5px;
      cursor: pointer;
      color: #eee;
    }
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }
    button.primary {
      background: #6366f1;
      color: white;
    }
    button.primary:hover {
      background: #4f46e5;
    }
    button.secondary {
      background: #4a4a6a;
      color: white;
    }
    button.secondary:hover {
      background: #5a5a7a;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .previews {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-top: 15px;
    }
    .preview-card {
      background: #1a1a2e;
      border-radius: 6px;
      padding: 10px;
      text-align: center;
    }
    .preview-card canvas {
      border: 1px solid #4a4a6a;
      border-radius: 4px;
    }
    .preview-card h3 {
      margin: 10px 0 5px;
      font-size: 0.9em;
      color: #ccc;
    }
    .preview-card p {
      margin: 0;
      font-size: 0.75em;
      color: #888;
    }
    .actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }
    .stat-card {
      background: #1a1a2e;
      border-radius: 6px;
      padding: 15px;
    }
    .stat-card .value {
      font-size: 1.5em;
      font-weight: bold;
      color: #6366f1;
    }
    .stat-card .label {
      font-size: 0.85em;
      color: #888;
      margin-top: 5px;
    }
    .status {
      margin-top: 15px;
      padding: 10px 15px;
      border-radius: 4px;
      font-size: 0.9em;
    }
    .status.loading {
      background: #2d2d4a;
      color: #aaa;
    }
    .status.success {
      background: #1a3a2a;
      color: #4ade80;
    }
    .status.error {
      background: #3a1a1a;
      color: #f87171;
    }
    .code-example {
      background: #1a1a2e;
      border-radius: 6px;
      padding: 15px;
      margin-top: 15px;
      overflow-x: auto;
    }
    .code-example pre {
      margin: 0;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.85em;
      color: #e2e8f0;
      white-space: pre-wrap;
    }
    .code-example .comment {
      color: #6b7280;
    }
    .code-example .keyword {
      color: #c084fc;
    }
    .code-example .string {
      color: #34d399;
    }
    .code-example .function {
      color: #60a5fa;
    }
    .layer-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 10px;
    }
    .layer-checkboxes label {
      display: flex;
      align-items: center;
      gap: 5px;
      cursor: pointer;
      color: #eee;
    }
  </style>
</head>
<body>
  <h1>exrs-wasm Demo</h1>
  <p>Generate multi-layer OpenEXR files directly in the browser using WebAssembly.</p>

  <div id="loading-status" class="status loading">Loading WASM module...</div>

  <div id="main-content" style="display: none;">
    <h2>Image Settings</h2>
    <div class="section">
      <div class="controls">
        <div class="control-group">
          <label for="width">Width</label>
          <input type="number" id="width" value="512" min="1" max="4096">
        </div>
        <div class="control-group">
          <label for="height">Height</label>
          <input type="number" id="height" value="512" min="1" max="4096">
        </div>
        <div class="control-group">
          <label for="compression">Compression</label>
          <select id="compression">
            <option value="0">None (fastest)</option>
            <option value="1" selected>RLE (default)</option>
            <option value="2">ZIP (single line)</option>
            <option value="3">ZIP16 (16 lines)</option>
            <option value="4">PIZ (wavelet)</option>
            <option value="5">PXR24 (lossy)</option>
          </select>
        </div>
        <div class="control-group">
          <label>Precision</label>
          <div class="radio-group">
            <label><input type="radio" name="precision" value="1" checked> F32</label>
            <label><input type="radio" name="precision" value="0"> F16</label>
          </div>
        </div>
      </div>
    </div>

    <h2>Layers to Include</h2>
    <div class="section">
      <div class="layer-checkboxes">
        <label><input type="checkbox" id="layer-beauty" checked> Beauty (RGBA)</label>
        <label><input type="checkbox" id="layer-depth" checked> Depth (Z)</label>
        <label><input type="checkbox" id="layer-normals" checked> Normals (RGB)</label>
        <label><input type="checkbox" id="layer-ao"> Ambient Occlusion (single)</label>
      </div>
    </div>

    <h2>Test Pattern Preview</h2>
    <div class="section">
      <div class="previews">
        <div class="preview-card">
          <canvas id="preview-beauty" width="128" height="128"></canvas>
          <h3>Beauty</h3>
          <p>RGBA gradient</p>
        </div>
        <div class="preview-card">
          <canvas id="preview-depth" width="128" height="128"></canvas>
          <h3>Depth</h3>
          <p>Radial Z-buffer</p>
        </div>
        <div class="preview-card">
          <canvas id="preview-normals" width="128" height="128"></canvas>
          <h3>Normals</h3>
          <p>Sphere normals</p>
        </div>
        <div class="preview-card">
          <canvas id="preview-ao" width="128" height="128"></canvas>
          <h3>AO</h3>
          <p>Noise pattern</p>
        </div>
      </div>
      <button class="secondary" onclick="updatePreviews()" style="margin-top: 15px;">Refresh Previews</button>
    </div>

    <h2>Generate EXR</h2>
    <div class="section">
      <div class="actions">
        <button class="primary" id="btn-generate" onclick="generateExr()">Generate &amp; Download EXR</button>
        <button class="secondary" id="btn-sequence" onclick="generateSequence()">Generate 3-Frame Sequence</button>
      </div>
      <div id="generate-status" class="status" style="display: none;"></div>
    </div>

    <h2>Output Statistics</h2>
    <div class="section">
      <div class="stats">
        <div class="stat-card">
          <div class="value" id="stat-size">-</div>
          <div class="label">File Size</div>
        </div>
        <div class="stat-card">
          <div class="value" id="stat-layers">-</div>
          <div class="label">Layers</div>
        </div>
        <div class="stat-card">
          <div class="value" id="stat-time">-</div>
          <div class="label">Encode Time</div>
        </div>
        <div class="stat-card">
          <div class="value" id="stat-dimensions">-</div>
          <div class="label">Dimensions</div>
        </div>
      </div>
    </div>

    <h2>Code Example</h2>
    <div class="section">
      <div class="code-example">
        <pre><span class="keyword">import</span> init, { ExrImage, CompressionMethod, SamplePrecision } <span class="keyword">from</span> <span class="string">'exrs-wasm'</span>;

<span class="comment">// Initialize WASM module</span>
<span class="keyword">await</span> <span class="function">init</span>();

<span class="comment">// Create a 1920x1080 EXR with RLE compression</span>
<span class="keyword">const</span> exr = <span class="keyword">new</span> <span class="function">ExrImage</span>(1920, 1080, CompressionMethod.Rle);

<span class="comment">// Add layers with pixel data (Float32Array)</span>
exr.<span class="function">addRgbaLayer</span>(<span class="string">'beauty'</span>, beautyPixels, SamplePrecision.F32);
exr.<span class="function">addDepthLayer</span>(<span class="string">'depth'</span>, depthPixels);
exr.<span class="function">addRgbLayer</span>(<span class="string">'normals'</span>, normalPixels);

<span class="comment">// Encode to bytes and download</span>
<span class="keyword">const</span> bytes = exr.<span class="function">toBytes</span>();
<span class="function">downloadBlob</span>(bytes, <span class="string">'render.exr'</span>);

<span class="comment">// Clean up (optional, uses FinalizationRegistry)</span>
exr.<span class="function">free</span>();</pre>
      </div>
    </div>
  </div>

  <script type="module">
    // Import from the pkg directory (relative to examples/)
    import init, {
      ExrImage,
      ExrSequenceWriter,
      CompressionMethod,
      SamplePrecision,
      init_panic_hook
    } from '../pkg/exrs_wasm.js';

    let wasmReady = false;

    async function initWasm() {
      try {
        await init();
        init_panic_hook();
        wasmReady = true;

        document.getElementById('loading-status').style.display = 'none';
        document.getElementById('main-content').style.display = 'block';

        updatePreviews();
      } catch (error) {
        const status = document.getElementById('loading-status');
        status.className = 'status error';
        status.textContent = `Failed to load WASM: ${error.message}`;
        console.error('WASM init error:', error);
      }
    }

    function generateBeautyData(width, height) {
      const data = new Float32Array(width * height * 4);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const i = (y * width + x) * 4;
          // Colorful gradient pattern
          const u = x / width;
          const v = y / height;
          data[i + 0] = u;                          // R: horizontal gradient
          data[i + 1] = v;                          // G: vertical gradient
          data[i + 2] = Math.sin(u * Math.PI) * Math.sin(v * Math.PI); // B: sine wave
          data[i + 3] = 1.0;                        // A: fully opaque
        }
      }
      return data;
    }

    function generateDepthData(width, height) {
      const data = new Float32Array(width * height);
      const cx = width / 2;
      const cy = height / 2;
      const maxDist = Math.sqrt(cx * cx + cy * cy);

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const dx = x - cx;
          const dy = y - cy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          // Depth increases from center (0) to edges (1)
          data[y * width + x] = dist / maxDist;
        }
      }
      return data;
    }

    function generateNormalsData(width, height) {
      const data = new Float32Array(width * height * 3);
      const cx = width / 2;
      const cy = height / 2;
      const radius = Math.min(width, height) / 2;

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const i = (y * width + x) * 3;
          const dx = (x - cx) / radius;
          const dy = (y - cy) / radius;
          const d2 = dx * dx + dy * dy;

          if (d2 <= 1.0) {
            // Point on sphere surface
            const dz = Math.sqrt(1.0 - d2);
            data[i + 0] = dx * 0.5 + 0.5;  // R: X normal (0-1)
            data[i + 1] = dy * 0.5 + 0.5;  // G: Y normal (0-1)
            data[i + 2] = dz;              // B: Z normal (0-1)
          } else {
            // Background - facing up
            data[i + 0] = 0.5;
            data[i + 1] = 0.5;
            data[i + 2] = 1.0;
          }
        }
      }
      return data;
    }

    function generateAOData(width, height) {
      const data = new Float32Array(width * height);
      // Simple noise pattern
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const noise = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 0.5 + 0.5;
          const checker = ((Math.floor(x / 32) + Math.floor(y / 32)) % 2) * 0.1;
          data[y * width + x] = Math.max(0, Math.min(1, noise + checker));
        }
      }
      return data;
    }

    function drawPreview(canvasId, data, channels) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const imageData = ctx.createImageData(width, height);

      // Sample the data (might be different size)
      const dataWidth = Math.sqrt(data.length / channels);

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const srcX = Math.floor(x * dataWidth / width);
          const srcY = Math.floor(y * dataWidth / height);
          const srcI = (srcY * dataWidth + srcX) * channels;
          const dstI = (y * width + x) * 4;

          if (channels === 4) {
            imageData.data[dstI + 0] = Math.floor(data[srcI + 0] * 255);
            imageData.data[dstI + 1] = Math.floor(data[srcI + 1] * 255);
            imageData.data[dstI + 2] = Math.floor(data[srcI + 2] * 255);
            imageData.data[dstI + 3] = Math.floor(data[srcI + 3] * 255);
          } else if (channels === 3) {
            imageData.data[dstI + 0] = Math.floor(data[srcI + 0] * 255);
            imageData.data[dstI + 1] = Math.floor(data[srcI + 1] * 255);
            imageData.data[dstI + 2] = Math.floor(data[srcI + 2] * 255);
            imageData.data[dstI + 3] = 255;
          } else {
            const v = Math.floor(data[srcI] * 255);
            imageData.data[dstI + 0] = v;
            imageData.data[dstI + 1] = v;
            imageData.data[dstI + 2] = v;
            imageData.data[dstI + 3] = 255;
          }
        }
      }

      ctx.putImageData(imageData, 0, 0);
    }

    function updatePreviews() {
      const size = 128; // Preview size
      drawPreview('preview-beauty', generateBeautyData(size, size), 4);
      drawPreview('preview-depth', generateDepthData(size, size), 1);
      drawPreview('preview-normals', generateNormalsData(size, size), 3);
      drawPreview('preview-ao', generateAOData(size, size), 1);
    }

    function getSettings() {
      return {
        width: parseInt(document.getElementById('width').value, 10),
        height: parseInt(document.getElementById('height').value, 10),
        compression: parseInt(document.getElementById('compression').value, 10),
        precision: parseInt(document.querySelector('input[name="precision"]:checked').value, 10),
        includeBeauty: document.getElementById('layer-beauty').checked,
        includeDepth: document.getElementById('layer-depth').checked,
        includeNormals: document.getElementById('layer-normals').checked,
        includeAO: document.getElementById('layer-ao').checked,
      };
    }

    function downloadBlob(bytes, filename) {
      const blob = new Blob([bytes], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function formatSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }

    function showStatus(message, type = 'loading') {
      const status = document.getElementById('generate-status');
      status.style.display = 'block';
      status.className = `status ${type}`;
      status.textContent = message;
    }

    function updateStats(size, layers, time, width, height) {
      document.getElementById('stat-size').textContent = formatSize(size);
      document.getElementById('stat-layers').textContent = layers;
      document.getElementById('stat-time').textContent = time.toFixed(1) + ' ms';
      document.getElementById('stat-dimensions').textContent = `${width} x ${height}`;
    }

    function generateExr() {
      if (!wasmReady) return;

      const settings = getSettings();
      const { width, height, compression, precision, includeBeauty, includeDepth, includeNormals, includeAO } = settings;

      if (!includeBeauty && !includeDepth && !includeNormals && !includeAO) {
        showStatus('Please select at least one layer', 'error');
        return;
      }

      showStatus('Generating EXR...', 'loading');

      try {
        const startTime = performance.now();

        const exr = new ExrImage(width, height, compression);

        if (includeBeauty) {
          const beauty = generateBeautyData(width, height);
          exr.addRgbaLayer('beauty', beauty, precision);
        }

        if (includeDepth) {
          const depth = generateDepthData(width, height);
          exr.addDepthLayer('depth', depth, precision);
        }

        if (includeNormals) {
          const normals = generateNormalsData(width, height);
          exr.addRgbLayer('normals', normals, precision);
        }

        if (includeAO) {
          const ao = generateAOData(width, height);
          exr.addSingleChannelLayer('ao', 'Y', ao, precision);
        }

        const bytes = exr.toBytes();
        const endTime = performance.now();

        updateStats(bytes.length, exr.layerCount, endTime - startTime, width, height);
        downloadBlob(bytes, 'render.exr');
        exr.free();

        showStatus('EXR generated successfully!', 'success');
      } catch (error) {
        showStatus(`Error: ${error.message || error}`, 'error');
        console.error('EXR generation error:', error);
      }
    }

    function generateSequence() {
      if (!wasmReady) return;

      const settings = getSettings();
      const { width, height, compression } = settings;

      showStatus('Generating 3-frame sequence...', 'loading');

      try {
        const startTime = performance.now();
        const writer = new ExrSequenceWriter(width, height, compression);

        let totalSize = 0;

        for (let frame = 0; frame < 3; frame++) {
          // Generate animated data (offset based on frame)
          const beauty = generateAnimatedBeauty(width, height, frame);
          const depth = generateDepthData(width, height);
          const normals = generateNormalsData(width, height);

          const bytes = writer.writeFrame(beauty, depth, normals);
          totalSize += bytes.length;
          downloadBlob(bytes, `render_${String(frame).padStart(4, '0')}.exr`);
        }

        const endTime = performance.now();
        updateStats(totalSize / 3, 3, (endTime - startTime) / 3, width, height);

        writer.free();

        showStatus('Sequence generated successfully! (3 files downloaded)', 'success');
      } catch (error) {
        showStatus(`Error: ${error.message || error}`, 'error');
        console.error('Sequence generation error:', error);
      }
    }

    function generateAnimatedBeauty(width, height, frame) {
      const data = new Float32Array(width * height * 4);
      const offset = frame * 0.1;

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const i = (y * width + x) * 4;
          const u = x / width;
          const v = y / height;

          // Animated wave pattern
          data[i + 0] = Math.sin((u + offset) * Math.PI * 2) * 0.5 + 0.5;
          data[i + 1] = Math.cos((v + offset) * Math.PI * 2) * 0.5 + 0.5;
          data[i + 2] = Math.sin((u + v + offset * 2) * Math.PI) * 0.5 + 0.5;
          data[i + 3] = 1.0;
        }
      }
      return data;
    }

    // Expose functions to window for onclick handlers
    window.updatePreviews = updatePreviews;
    window.generateExr = generateExr;
    window.generateSequence = generateSequence;

    // Initialize on load
    initWasm();
  </script>
</body>
</html>
