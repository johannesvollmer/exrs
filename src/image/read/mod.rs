use crate::image::*;
use crate::io::Read;
use std::io::Seek;
use crate::meta::header::{Header, ImageAttributes, LayerAttributes};
use crate::meta::TileIndices;
use crate::block::chunk::Block;
use crate::error::{Result, UnitResult, Error};
use crate::block::UncompressedBlock;
use crate::block::lines::LineRef;
use crate::math::Vec2;
use crate::meta::attribute::Text;


/// `ReadX` traits: contain reader options, which will be cloned to obtain a stateful reader

pub struct ReadImage<C: ReadChannels> {
    read_channels: C,
}

trait ReadChannels {
    type Reader: ChannelsReader;
    fn create_reader(&self, meta_data: &Header) -> Result<Self::Reader>;
}

pub struct ReadRgbaChannels<Set, Create> {
    create: Create,
    set_pixel: Set
}

pub struct ReadAnyChannels<S: ReadSamples> {
    read_samples: S
}

trait ReadSamples {}

pub struct ReadFlatSamples;
pub struct ReadAnySamples;



/// `XReader` structs: contain temporary data and build up the result

/// `C`: either `RgbaChannelsReader` or `AnyChannelsReader<AnySamplesReader>` or `AnyChannelsReader<FlatSamplesReader>`
pub struct ImageReader<C> where C: ChannelsReader {
    attributes: ImageAttributes,

    /// one per layer
    layer_channel_readers: Vec<LayerReader<C>>,
}

pub type LayerReader<C> = (LayerAttributes, C);

pub trait ChannelsReader {
    type Channels;
    fn read_block(&mut self, block: UncompressedBlock) -> UnitResult;
    fn into_channels(self) -> Self::Channels;
}

pub struct RgbaChannelsReader<Setter, Image> where
    Setter: FnMut(&mut Image, RgbaPixel)
{
    storage: Image,
    set_pixel: Setter,
    rgba_channel_indices: (usize, usize, usize, Option<usize>),
}

/// `S`: Either `AnySamplesReader` or `FlatSamplesReader`
pub struct AnyChannelsReader<S> where S: SamplesReader {

    /// one per channel
    sample_channels_reader: Vec<AnyChannelReader<S>>,
}

pub type AnyChannelReader<S> = (Text, S);

pub trait SamplesReader {
    type Samples;
    fn read_line(&mut self, line: LineRef<'_>) -> UnitResult;
    fn into_samples(self) -> Self::Samples;
}

/// either deep or flat samples
pub struct AnySamplesReader {
    resolution: Vec2<usize>,
    samples: AnySamples
}

pub struct FlatSamplesReader {
    resolution: Vec2<usize>,
    samples: FlatSamples
}


impl<C> ReadImage<C> where C: ReadChannels {

    fn create_reader(&self, headers: &[Header]) -> Result<ImageReader<C::Reader>> {
        Ok(ImageReader {
            attributes: meta_data,
            layer_channel_readers: headers.iter()
                .map(|header| self.read_channels.create_reader(header))
                .collect()
        })
    }

    pub fn read_from_buffered(&self, read: impl Read + Seek + Send) -> Result<Image<C::Reader>> {
        let reader = crate::block::read_filtered_blocks_from_buffered(
            read,

            |headers| self.create_reader(headers),

            |reader, header, tile| {
                true // TODO
            },

            |reader, header, block| {
                reader.read_block(block)
            },

            options
        )?;

        Ok(reader.into_image())
    }

}

impl<C: ChannelsReader> ImageReader<C> {

    pub fn read_block(&mut self, block: UncompressedBlock) -> UnitResult {
        self.layer_channel_readers
            .get(block.index.layer).unwrap()
            .read_block(block)
    }

    pub fn into_image(self) -> Image<C::Channels> {
        Image {
            image_attributes: self.attributes,
            layers: self.layer_channel_readers.into_iter()
                .map(|layer| layer.into_channels()).collect()
        }
    }
}


// TODO impl SamplesReader for AnySamples { }

impl SamplesReader for FlatSamplesReader {
    type Samples = FlatSamples;

    fn read_line(&mut self, line: LineRef<'_>) -> UnitResult {
        let index = line.location;
        let resolution = self.resolution;

        // the index is generated by ourselves and must always be correct
        debug_assert!(index.position.x() + index.sample_count <= resolution.width(), "line index calculation bug");
        debug_assert!(index.position.y() < resolution.height(), "line index calculation bug");
        debug_assert_ne!(resolution.0, 0, "sample size but");

        let start_index = index.position.y() * resolution.width() + index.position.x();
        let end_index = start_index + index.sample_count;

        match &mut self.samples {
            FlatSamples::F16(samples) =>
                line.write_samples_from_slice(&samples[start_index .. end_index])
                    .expect("writing line bytes failed"),

            FlatSamples::F32(samples) =>
                line.write_samples_from_slice(&samples[start_index .. end_index])
                    .expect("writing line bytes failed"),

            FlatSamples::U32(samples) =>
                line.write_samples_from_slice(&samples[start_index .. end_index])
                    .expect("writing line bytes failed"),
        }
    }

    fn into_samples(self) -> FlatSamples {
        self.samples
    }
}



impl<Setter, Constructor, Image>
    ReadChannels for ReadRgbaChannels<Setter, Constructor>

    where
        Constructor: FnOnce(RgbaImageInfo) -> Image,
        Setter: FnMut(&mut Image, RgbaPixel)
{
    type Reader = RgbaChannelsReader<Setter, Image>;

    fn create_reader(&self, meta_data: &Header) -> Result<Self::Reader> {
        if header.is_deep { return Err(Error::invalid("image has deep data, no rgba pixels")); }
        if channels != &["A", "R", "G", "B"] { return Err(Error::invalid("image does not contain rgba channels")); }
        let info = RgbaImageInfo::new(meta_data);

        Ok(RgbaChannelsReader {
            storage: self.create(info),
            set_pixel: &self.set_pixel,
            rgba_channel_indices: (0, 0, 0, None) // TODO
        })
    }
}

impl<Setter, Storage>
    ChannelsReader for RgbaChannelsReader<Setter, Storage>
    where Setter: FnMut(&mut Storage, RgbaPixel)
{
    type Channels = Storage;

    fn read_block(&mut self, block: UncompressedBlock) -> UnitResult {
        for pixel in block {
            self.set_pixel(&mut self.storage, pixel);
        }

        Ok(())
    }

    fn into_channels(self) -> Self::Channels {
        self.storage
    }
}
